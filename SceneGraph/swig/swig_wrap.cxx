/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/* Support for throwing C# exceptions from C/C++. There are two types: 
 * Exceptions that take a message and ArgumentExceptions that take a message and a parameter name. */
typedef enum {
  SWIG_CSharpApplicationException,
  SWIG_CSharpArithmeticException,
  SWIG_CSharpDivideByZeroException,
  SWIG_CSharpIndexOutOfRangeException,
  SWIG_CSharpInvalidCastException,
  SWIG_CSharpInvalidOperationException,
  SWIG_CSharpIOException,
  SWIG_CSharpNullReferenceException,
  SWIG_CSharpOutOfMemoryException,
  SWIG_CSharpOverflowException,
  SWIG_CSharpSystemException
} SWIG_CSharpExceptionCodes;

typedef enum {
  SWIG_CSharpArgumentException,
  SWIG_CSharpArgumentNullException,
  SWIG_CSharpArgumentOutOfRangeException
} SWIG_CSharpExceptionArgumentCodes;

typedef void (SWIGSTDCALL* SWIG_CSharpExceptionCallback_t)(const char *);
typedef void (SWIGSTDCALL* SWIG_CSharpExceptionArgumentCallback_t)(const char *, const char *);

typedef struct {
  SWIG_CSharpExceptionCodes code;
  SWIG_CSharpExceptionCallback_t callback;
} SWIG_CSharpException_t;

typedef struct {
  SWIG_CSharpExceptionArgumentCodes code;
  SWIG_CSharpExceptionArgumentCallback_t callback;
} SWIG_CSharpExceptionArgument_t;

static SWIG_CSharpException_t SWIG_csharp_exceptions[] = {
  { SWIG_CSharpApplicationException, NULL },
  { SWIG_CSharpArithmeticException, NULL },
  { SWIG_CSharpDivideByZeroException, NULL },
  { SWIG_CSharpIndexOutOfRangeException, NULL },
  { SWIG_CSharpInvalidCastException, NULL },
  { SWIG_CSharpInvalidOperationException, NULL },
  { SWIG_CSharpIOException, NULL },
  { SWIG_CSharpNullReferenceException, NULL },
  { SWIG_CSharpOutOfMemoryException, NULL },
  { SWIG_CSharpOverflowException, NULL },
  { SWIG_CSharpSystemException, NULL }
};

static SWIG_CSharpExceptionArgument_t SWIG_csharp_exceptions_argument[] = {
  { SWIG_CSharpArgumentException, NULL },
  { SWIG_CSharpArgumentNullException, NULL },
  { SWIG_CSharpArgumentOutOfRangeException, NULL }
};

static void SWIGUNUSED SWIG_CSharpSetPendingException(SWIG_CSharpExceptionCodes code, const char *msg) {
  SWIG_CSharpExceptionCallback_t callback = SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions)/sizeof(SWIG_CSharpException_t)) {
    callback = SWIG_csharp_exceptions[code].callback;
  }
  callback(msg);
}

static void SWIGUNUSED SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpExceptionArgumentCodes code, const char *msg, const char *param_name) {
  SWIG_CSharpExceptionArgumentCallback_t callback = SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback;
  if ((size_t)code < sizeof(SWIG_csharp_exceptions_argument)/sizeof(SWIG_CSharpExceptionArgument_t)) {
    callback = SWIG_csharp_exceptions_argument[code].callback;
  }
  callback(msg, param_name);
}


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionCallbacks_eh(
                                                SWIG_CSharpExceptionCallback_t applicationCallback,
                                                SWIG_CSharpExceptionCallback_t arithmeticCallback,
                                                SWIG_CSharpExceptionCallback_t divideByZeroCallback, 
                                                SWIG_CSharpExceptionCallback_t indexOutOfRangeCallback, 
                                                SWIG_CSharpExceptionCallback_t invalidCastCallback,
                                                SWIG_CSharpExceptionCallback_t invalidOperationCallback,
                                                SWIG_CSharpExceptionCallback_t ioCallback,
                                                SWIG_CSharpExceptionCallback_t nullReferenceCallback,
                                                SWIG_CSharpExceptionCallback_t outOfMemoryCallback, 
                                                SWIG_CSharpExceptionCallback_t overflowCallback, 
                                                SWIG_CSharpExceptionCallback_t systemCallback) {
  SWIG_csharp_exceptions[SWIG_CSharpApplicationException].callback = applicationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpArithmeticException].callback = arithmeticCallback;
  SWIG_csharp_exceptions[SWIG_CSharpDivideByZeroException].callback = divideByZeroCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIndexOutOfRangeException].callback = indexOutOfRangeCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidCastException].callback = invalidCastCallback;
  SWIG_csharp_exceptions[SWIG_CSharpInvalidOperationException].callback = invalidOperationCallback;
  SWIG_csharp_exceptions[SWIG_CSharpIOException].callback = ioCallback;
  SWIG_csharp_exceptions[SWIG_CSharpNullReferenceException].callback = nullReferenceCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOutOfMemoryException].callback = outOfMemoryCallback;
  SWIG_csharp_exceptions[SWIG_CSharpOverflowException].callback = overflowCallback;
  SWIG_csharp_exceptions[SWIG_CSharpSystemException].callback = systemCallback;
}

#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterExceptionArgumentCallbacks_eh(
                                                SWIG_CSharpExceptionArgumentCallback_t argumentCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentNullCallback,
                                                SWIG_CSharpExceptionArgumentCallback_t argumentOutOfRangeCallback) {
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentException].callback = argumentCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentNullException].callback = argumentNullCallback;
  SWIG_csharp_exceptions_argument[SWIG_CSharpArgumentOutOfRangeException].callback = argumentOutOfRangeCallback;
}


/* Callback for returning strings to C# without leaking memory */
typedef char * (SWIGSTDCALL* SWIG_CSharpStringHelperCallback)(const char *);
static SWIG_CSharpStringHelperCallback SWIG_csharp_string_callback = NULL;


#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterStringCallback_eh(SWIG_CSharpStringHelperCallback callback) {
  SWIG_csharp_string_callback = callback;
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, msg, ""); return nullreturn; } else


/* Callback for returning strings to C# without leaking memory */
typedef void * (SWIGSTDCALL* SWIG_CSharpWStringHelperCallback)(const wchar_t *);
static SWIG_CSharpWStringHelperCallback SWIG_csharp_wstring_callback = NULL;


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void SWIGSTDCALL SWIGRegisterWStringCallback_eh(SWIG_CSharpWStringHelperCallback callback) {
  SWIG_csharp_wstring_callback = callback;
}

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that C# proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif
#include <string>
#include <exception>

namespace Swig {
  /* Director base class - not currently used in C# directors */
  class Director {
  };

  /* Base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;

  public:
    DirectorException(const char *msg) : swig_msg(msg) {
    }

    DirectorException(const std::string &msg) : swig_msg(msg) {
    }

    virtual ~DirectorException() throw() {
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  /* Pure virtual method exception */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg) : DirectorException(std::string("Attempt to invoke pure virtual method ") + msg) {
    }
  };
}


		#include "..\src\math3d.hpp"
        #include "swig.h"


#include <string>


#include <string>


#include <typeinfo>
#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>

SWIGINTERN std::vector< int > *new_std_vector_Sl_int_Sg___SWIG_2(int capacity){
        std::vector< int >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< int >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN int std_vector_Sl_int_Sg__getitemcopy(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN int const &std_vector_Sl_int_Sg__getitem(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__setitem(std::vector< int > *self,int index,int const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__AddRange(std::vector< int > *self,std::vector< int > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__GetRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< int >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Insert(std::vector< int > *self,int index,int const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__InsertRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveAt(std::vector< int > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_int_Sg__RemoveRange(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< int > *std_vector_Sl_int_Sg__Repeat(int const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< int >(count, value);
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_0(std::vector< int > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_int_Sg__Reverse__SWIG_1(std::vector< int > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_int_Sg__SetRange(std::vector< int > *self,int index,std::vector< int > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Contains(std::vector< int > *self,int const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_int_Sg__IndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_int_Sg__LastIndexOf(std::vector< int > *self,int const &value){
        int index = -1;
        std::vector< int >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_int_Sg__Remove(std::vector< int > *self,int const &value){
        std::vector< int >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< std::wstring > *new_std_vector_Sl_std_wstring_Sg___SWIG_2(int capacity){
        std::vector< std::wstring >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< std::wstring >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN std::wstring std_vector_Sl_std_wstring_Sg__getitemcopy(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN std::wstring const &std_vector_Sl_std_wstring_Sg__getitem(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__setitem(std::vector< std::wstring > *self,int index,std::wstring const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__AddRange(std::vector< std::wstring > *self,std::vector< std::wstring > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< std::wstring > *std_vector_Sl_std_wstring_Sg__GetRange(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< std::wstring >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Insert(std::vector< std::wstring > *self,int index,std::wstring const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__InsertRange(std::vector< std::wstring > *self,int index,std::vector< std::wstring > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__RemoveAt(std::vector< std::wstring > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__RemoveRange(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< std::wstring > *std_vector_Sl_std_wstring_Sg__Repeat(std::wstring const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< std::wstring >(count, value);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Reverse__SWIG_0(std::vector< std::wstring > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__Reverse__SWIG_1(std::vector< std::wstring > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_std_wstring_Sg__SetRange(std::vector< std::wstring > *self,int index,std::vector< std::wstring > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }
SWIGINTERN bool std_vector_Sl_std_wstring_Sg__Contains(std::vector< std::wstring > *self,std::wstring const &value){
        return std::find(self->begin(), self->end(), value) != self->end();
      }
SWIGINTERN int std_vector_Sl_std_wstring_Sg__IndexOf(std::vector< std::wstring > *self,std::wstring const &value){
        int index = -1;
        std::vector< std::wstring >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end())
          index = (int)(it - self->begin());
        return index;
      }
SWIGINTERN int std_vector_Sl_std_wstring_Sg__LastIndexOf(std::vector< std::wstring > *self,std::wstring const &value){
        int index = -1;
        std::vector< std::wstring >::reverse_iterator rit = std::find(self->rbegin(), self->rend(), value);
        if (rit != self->rend())
          index = (int)(self->rend() - 1 - rit);
        return index;
      }
SWIGINTERN bool std_vector_Sl_std_wstring_Sg__Remove(std::vector< std::wstring > *self,std::wstring const &value){
        std::vector< std::wstring >::iterator it = std::find(self->begin(), self->end(), value);
        if (it != self->end()) {
          self->erase(it);
	  return true;
        }
        return false;
      }
SWIGINTERN std::vector< math3D::Vec3 > *new_std_vector_Sl_math3D_Vec3_Sg___SWIG_2(int capacity){
        std::vector< math3D::Vec3 >* pv = 0;
        if (capacity >= 0) {
          pv = new std::vector< math3D::Vec3 >();
          pv->reserve(capacity);
       } else {
          throw std::out_of_range("capacity");
       }
       return pv;
      }
SWIGINTERN math3D::Vec3 std_vector_Sl_math3D_Vec3_Sg__getitemcopy(std::vector< math3D::Vec3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN math3D::Vec3 const &std_vector_Sl_math3D_Vec3_Sg__getitem(std::vector< math3D::Vec3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          return (*self)[index];
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__setitem(std::vector< math3D::Vec3 > *self,int index,math3D::Vec3 const &val){
        if (index>=0 && index<(int)self->size())
          (*self)[index] = val;
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__AddRange(std::vector< math3D::Vec3 > *self,std::vector< math3D::Vec3 > const &values){
        self->insert(self->end(), values.begin(), values.end());
      }
SWIGINTERN std::vector< math3D::Vec3 > *std_vector_Sl_math3D_Vec3_Sg__GetRange(std::vector< math3D::Vec3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        return new std::vector< math3D::Vec3 >(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__Insert(std::vector< math3D::Vec3 > *self,int index,math3D::Vec3 const &x){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, x);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__InsertRange(std::vector< math3D::Vec3 > *self,int index,std::vector< math3D::Vec3 > const &values){
        if (index>=0 && index<(int)self->size()+1)
          self->insert(self->begin()+index, values.begin(), values.end());
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__RemoveAt(std::vector< math3D::Vec3 > *self,int index){
        if (index>=0 && index<(int)self->size())
          self->erase(self->begin() + index);
        else
          throw std::out_of_range("index");
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__RemoveRange(std::vector< math3D::Vec3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        self->erase(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN std::vector< math3D::Vec3 > *std_vector_Sl_math3D_Vec3_Sg__Repeat(math3D::Vec3 const &value,int count){
        if (count < 0)
          throw std::out_of_range("count");
        return new std::vector< math3D::Vec3 >(count, value);
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__Reverse__SWIG_0(std::vector< math3D::Vec3 > *self){
        std::reverse(self->begin(), self->end());
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__Reverse__SWIG_1(std::vector< math3D::Vec3 > *self,int index,int count){
        if (index < 0)
          throw std::out_of_range("index");
        if (count < 0)
          throw std::out_of_range("count");
        if (index >= (int)self->size()+1 || index+count > (int)self->size())
          throw std::invalid_argument("invalid range");
        std::reverse(self->begin()+index, self->begin()+index+count);
      }
SWIGINTERN void std_vector_Sl_math3D_Vec3_Sg__SetRange(std::vector< math3D::Vec3 > *self,int index,std::vector< math3D::Vec3 > const &values){
        if (index < 0)
          throw std::out_of_range("index");
        if (index+values.size() > self->size())
          throw std::out_of_range("index");
        std::copy(values.begin(), values.end(), self->begin()+index);
      }

struct SWIG_null_deleter {
  void operator() (void const *) const {
  }
};
#define SWIG_NO_NULL_DELETER_0 , SWIG_null_deleter()
#define SWIG_NO_NULL_DELETER_1
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_NEW
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_OWN



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "swig_wrap.h"

SwigDirector_Callback::SwigDirector_Callback() : swig::Callback(), Swig::Director() {
  swig_init_callbacks();
}

SwigDirector_Callback::~SwigDirector_Callback() {
  
}


void SwigDirector_Callback::Call(float value) {
  float jvalue  ;
  
  if (!swig_callbackCall) {
    swig::Callback::Call(value);
    return;
  } else {
    jvalue = value;
    swig_callbackCall(jvalue);
  }
}

void SwigDirector_Callback::swig_connect_director(SWIG_Callback0_t callbackCall) {
  swig_callbackCall = callbackCall;
}

void SwigDirector_Callback::swig_init_callbacks() {
  swig_callbackCall = 0;
}

SwigDirector_IPlugIn::SwigDirector_IPlugIn() : swig::IPlugIn(), Swig::Director() {
  swig_init_callbacks();
}

std::wstring SwigDirector_IPlugIn::GetAboutString() const {
  std::wstring c_result ;
  wchar_t * jresult = 0 ;
  
  if (!swig_callbackGetAboutString) {
    throw Swig::DirectorPureVirtualException("swig::IPlugIn::GetAboutString");
  } else {
    jresult = (wchar_t *) swig_callbackGetAboutString();
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
      return c_result;
    }
    c_result.assign(jresult); 
  }
  return c_result;
}

int SwigDirector_IPlugIn::GetFileTypeCount() const {
  int c_result = SwigValueInit< int >() ;
  int jresult = 0 ;
  
  if (!swig_callbackGetFileTypeCount) {
    throw Swig::DirectorPureVirtualException("swig::IPlugIn::GetFileTypeCount");
  } else {
    jresult = (int) swig_callbackGetFileTypeCount();
    c_result = (int)jresult; 
  }
  return c_result;
}

std::wstring SwigDirector_IPlugIn::GetFileType(int i) {
  std::wstring c_result ;
  wchar_t * jresult = 0 ;
  int ji  ;
  
  if (!swig_callbackGetFileType) {
    throw Swig::DirectorPureVirtualException("swig::IPlugIn::GetFileType");
  } else {
    ji = i;
    jresult = (wchar_t *) swig_callbackGetFileType(ji);
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
      return c_result;
    }
    c_result.assign(jresult); 
  }
  return c_result;
}

std::wstring SwigDirector_IPlugIn::GetFileExtention(int i) {
  std::wstring c_result ;
  wchar_t * jresult = 0 ;
  int ji  ;
  
  if (!swig_callbackGetFileExtention) {
    throw Swig::DirectorPureVirtualException("swig::IPlugIn::GetFileExtention");
  } else {
    ji = i;
    jresult = (wchar_t *) swig_callbackGetFileExtention(ji);
    if (!jresult) {
      SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
      return c_result;
    }
    c_result.assign(jresult); 
  }
  return c_result;
}

bool SwigDirector_IPlugIn::ReadFile(std::wstring aFile, void *sceneHandle, swig::Callback *callback) {
  bool c_result = SwigValueInit< bool >() ;
  unsigned int jresult = 0 ;
  void * jaFile  ;
  void * jsceneHandle = 0 ;
  void * jcallback = 0 ;
  
  if (!swig_callbackReadFile__SWIG_0) {
    throw Swig::DirectorPureVirtualException("swig::IPlugIn::ReadFile");
  } else {
    jaFile = SWIG_csharp_wstring_callback((&aFile)->c_str()); 
    jsceneHandle = (void *) sceneHandle; 
    jcallback = (void *) callback; 
    jresult = (unsigned int) swig_callbackReadFile__SWIG_0(jaFile, jsceneHandle, jcallback);
    c_result = jresult ? true : false; 
  }
  return c_result;
}

void SwigDirector_IPlugIn::swig_connect_director(SWIG_Callback0_t callbackGetAboutString, SWIG_Callback1_t callbackGetFileTypeCount, SWIG_Callback2_t callbackGetFileType, SWIG_Callback3_t callbackGetFileExtention, SWIG_Callback4_t callbackReadFile__SWIG_0, SWIG_Callback5_t callbackReadFile__SWIG_1) {
  swig_callbackGetAboutString = callbackGetAboutString;
  swig_callbackGetFileTypeCount = callbackGetFileTypeCount;
  swig_callbackGetFileType = callbackGetFileType;
  swig_callbackGetFileExtention = callbackGetFileExtention;
  swig_callbackReadFile__SWIG_0 = callbackReadFile__SWIG_0;
  swig_callbackReadFile__SWIG_1 = callbackReadFile__SWIG_1;
}

void SwigDirector_IPlugIn::swig_init_callbacks() {
  swig_callbackGetAboutString = 0;
  swig_callbackGetFileTypeCount = 0;
  swig_callbackGetFileType = 0;
  swig_callbackGetFileExtention = 0;
  swig_callbackReadFile__SWIG_0 = 0;
  swig_callbackReadFile__SWIG_1 = 0;
}


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_Clear(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_Add(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  (arg1)->push_back((int const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_IntVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_IntVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  arg1 = (std::vector< int > *)jarg1; 
  result = ((std::vector< int > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_IntVector__SWIG_0() {
  void * jresult ;
  std::vector< int > *result = 0 ;
  
  result = (std::vector< int > *)new std::vector< int >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_IntVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_IntVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< int > *)new_std_vector_Sl_int_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IntVector_getitemcopy(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int)std_vector_Sl_int_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IntVector_getitem(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (int *) &std_vector_Sl_int_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = *result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_setitem(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__setitem(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (std::vector< int > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_int_Sg__AddRange(arg1,(std::vector< int > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IntVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_Insert(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  temp3 = (int)jarg3; 
  arg3 = &temp3; 
  try {
    std_vector_Sl_int_Sg__Insert(arg1,arg2,(int const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__InsertRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_int_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IntVector_Repeat(int jarg1, int jarg2) {
  void * jresult ;
  int *arg1 = 0 ;
  int arg2 ;
  int temp1 ;
  std::vector< int > *result = 0 ;
  
  temp1 = (int)jarg1; 
  arg1 = &temp1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< int > *)std_vector_Sl_int_Sg__Repeat((int const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  std_vector_Sl_int_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_int_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IntVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int arg2 ;
  std::vector< int > *arg3 = 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< int > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< int > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_int_Sg__SetRange(arg1,arg2,(std::vector< int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IntVector_Contains(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Contains(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IntVector_IndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__IndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IntVector_LastIndexOf(void * jarg1, int jarg2) {
  int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  int result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (int)std_vector_Sl_int_Sg__LastIndexOf(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IntVector_Remove(void * jarg1, int jarg2) {
  unsigned int jresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  bool result;
  
  arg1 = (std::vector< int > *)jarg1; 
  temp2 = (int)jarg2; 
  arg2 = &temp2; 
  result = (bool)std_vector_Sl_int_Sg__Remove(arg1,(int const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IntVector(void * jarg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_Clear(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_Add(void * jarg1, wchar_t * jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  (arg1)->push_back((std::wstring const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_StringVector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  result = ((std::vector< std::wstring > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_StringVector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  result = ((std::vector< std::wstring > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring >::size_type arg2 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (std::vector< std::wstring >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_StringVector__SWIG_0() {
  void * jresult ;
  std::vector< std::wstring > *result = 0 ;
  
  result = (std::vector< std::wstring > *)new std::vector< std::wstring >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_StringVector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = 0 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< std::wstring > *)new std::vector< std::wstring >((std::vector< std::wstring > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_StringVector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< std::wstring > *)new_std_vector_Sl_std_wstring_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_StringVector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_std_wstring_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_StringVector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (std::wstring *) &std_vector_Sl_std_wstring_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = SWIG_csharp_wstring_callback(result->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_setitem(void * jarg1, int jarg2, wchar_t * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_wstring_Sg__setitem(arg1,arg2,(std::wstring const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_AddRange(void * jarg1, void * jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::vector< std::wstring > *arg2 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (std::vector< std::wstring > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_std_wstring_Sg__AddRange(arg1,(std::vector< std::wstring > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_StringVector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< std::wstring > *result = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< std::wstring > *)std_vector_Sl_std_wstring_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_Insert(void * jarg1, int jarg2, wchar_t * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::wstring *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  if (!jarg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  std::wstring arg3_str(jarg3);
  arg3 = &arg3_str; 
  try {
    std_vector_Sl_std_wstring_Sg__Insert(arg1,arg2,(std::wstring const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::vector< std::wstring > *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::wstring > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_wstring_Sg__InsertRange(arg1,arg2,(std::vector< std::wstring > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_std_wstring_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_wstring_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_StringVector_Repeat(wchar_t * jarg1, int jarg2) {
  void * jresult ;
  std::wstring *arg1 = 0 ;
  int arg2 ;
  std::vector< std::wstring > *result = 0 ;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg1_str(jarg1);
  arg1 = &arg1_str; 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< std::wstring > *)std_vector_Sl_std_wstring_Sg__Repeat((std::wstring const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_Reverse__SWIG_0(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  std_vector_Sl_std_wstring_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_std_wstring_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_StringVector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  int arg2 ;
  std::vector< std::wstring > *arg3 = 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< std::wstring > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< std::wstring > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_std_wstring_Sg__SetRange(arg1,arg2,(std::vector< std::wstring > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_StringVector_Contains(void * jarg1, wchar_t * jarg2) {
  unsigned int jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_vector_Sl_std_wstring_Sg__Contains(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_StringVector_IndexOf(void * jarg1, wchar_t * jarg2) {
  int jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (int)std_vector_Sl_std_wstring_Sg__IndexOf(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_StringVector_LastIndexOf(void * jarg1, wchar_t * jarg2) {
  int jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  int result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (int)std_vector_Sl_std_wstring_Sg__LastIndexOf(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_StringVector_Remove(void * jarg1, wchar_t * jarg2) {
  unsigned int jresult ;
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  std::wstring *arg2 = 0 ;
  bool result;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  std::wstring arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)std_vector_Sl_std_wstring_Sg__Remove(arg1,(std::wstring const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_StringVector(void * jarg1) {
  std::vector< std::wstring > *arg1 = (std::vector< std::wstring > *) 0 ;
  
  arg1 = (std::vector< std::wstring > *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_Clear(void * jarg1) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  (arg1)->clear();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_Add(void * jarg1, void * jarg2) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  (arg1)->push_back((math3D::Vec3 const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_Vec3Vector_size(void * jarg1) {
  unsigned long jresult ;
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  std::vector< math3D::Vec3 >::size_type result;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  result = ((std::vector< math3D::Vec3 > const *)arg1)->size();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_Vec3Vector_capacity(void * jarg1) {
  unsigned long jresult ;
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  std::vector< math3D::Vec3 >::size_type result;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  result = ((std::vector< math3D::Vec3 > const *)arg1)->capacity();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_reserve(void * jarg1, unsigned long jarg2) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  std::vector< math3D::Vec3 >::size_type arg2 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (std::vector< math3D::Vec3 >::size_type)jarg2; 
  (arg1)->reserve(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3Vector__SWIG_0() {
  void * jresult ;
  std::vector< math3D::Vec3 > *result = 0 ;
  
  result = (std::vector< math3D::Vec3 > *)new std::vector< math3D::Vec3 >();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3Vector__SWIG_1(void * jarg1) {
  void * jresult ;
  std::vector< math3D::Vec3 > *arg1 = 0 ;
  std::vector< math3D::Vec3 > *result = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< math3D::Vec3 > const & type is null", 0);
    return 0;
  } 
  result = (std::vector< math3D::Vec3 > *)new std::vector< math3D::Vec3 >((std::vector< math3D::Vec3 > const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3Vector__SWIG_2(int jarg1) {
  void * jresult ;
  int arg1 ;
  std::vector< math3D::Vec3 > *result = 0 ;
  
  arg1 = (int)jarg1; 
  try {
    result = (std::vector< math3D::Vec3 > *)new_std_vector_Sl_math3D_Vec3_Sg___SWIG_2(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3Vector_getitemcopy(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  math3D::Vec3 result;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = std_vector_Sl_math3D_Vec3_Sg__getitemcopy(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3Vector_getitem(void * jarg1, int jarg2) {
  void * jresult ;
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    result = (math3D::Vec3 *) &std_vector_Sl_math3D_Vec3_Sg__getitem(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_setitem(void * jarg1, int jarg2, void * jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  math3D::Vec3 *arg3 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_math3D_Vec3_Sg__setitem(arg1,arg2,(math3D::Vec3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_AddRange(void * jarg1, void * jarg2) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  std::vector< math3D::Vec3 > *arg2 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (std::vector< math3D::Vec3 > *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< math3D::Vec3 > const & type is null", 0);
    return ;
  } 
  std_vector_Sl_math3D_Vec3_Sg__AddRange(arg1,(std::vector< math3D::Vec3 > const &)*arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3Vector_GetRange(void * jarg1, int jarg2, int jarg3) {
  void * jresult ;
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  std::vector< math3D::Vec3 > *result = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    result = (std::vector< math3D::Vec3 > *)std_vector_Sl_math3D_Vec3_Sg__GetRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_Insert(void * jarg1, int jarg2, void * jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  math3D::Vec3 *arg3 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_math3D_Vec3_Sg__Insert(arg1,arg2,(math3D::Vec3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_InsertRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  std::vector< math3D::Vec3 > *arg3 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< math3D::Vec3 > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< math3D::Vec3 > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_math3D_Vec3_Sg__InsertRange(arg1,arg2,(std::vector< math3D::Vec3 > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_RemoveAt(void * jarg1, int jarg2) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  try {
    std_vector_Sl_math3D_Vec3_Sg__RemoveAt(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_RemoveRange(void * jarg1, int jarg2, int jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_math3D_Vec3_Sg__RemoveRange(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3Vector_Repeat(void * jarg1, int jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  int arg2 ;
  std::vector< math3D::Vec3 > *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (int)jarg2; 
  try {
    result = (std::vector< math3D::Vec3 > *)std_vector_Sl_math3D_Vec3_Sg__Repeat((math3D::Vec3 const &)*arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return 0;
  }
  
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_Reverse__SWIG_0(void * jarg1) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  std_vector_Sl_math3D_Vec3_Sg__Reverse__SWIG_0(arg1);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_Reverse__SWIG_1(void * jarg1, int jarg2, int jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  int arg3 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  try {
    std_vector_Sl_math3D_Vec3_Sg__Reverse__SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  catch(std::invalid_argument &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentException, (&_e)->what(), "");
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3Vector_SetRange(void * jarg1, int jarg2, void * jarg3) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  int arg2 ;
  std::vector< math3D::Vec3 > *arg3 = 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (std::vector< math3D::Vec3 > *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "std::vector< math3D::Vec3 > const & type is null", 0);
    return ;
  } 
  try {
    std_vector_Sl_math3D_Vec3_Sg__SetRange(arg1,arg2,(std::vector< math3D::Vec3 > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentOutOfRangeException, 0, (&_e)->what());
    return ;
  }
  
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Vec3Vector(void * jarg1) {
  std::vector< math3D::Vec3 > *arg1 = (std::vector< math3D::Vec3 > *) 0 ;
  
  arg1 = (std::vector< math3D::Vec3 > *)jarg1; 
  delete arg1;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_PI_get() {
  float jresult ;
  math3D::Float result;
  
  result = (math3D::Float)(math3D::Float)math3D::PI;
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_fequal(float jarg1, float jarg2) {
  unsigned int jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  bool result;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  result = (bool)math3D::fequal(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_fmin(float jarg1, float jarg2) {
  float jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float result;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  result = (math3D::Float)math3D::fmin(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_fmax(float jarg1, float jarg2) {
  float jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float result;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  result = (math3D::Float)math3D::fmax(arg1,arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_fswap(void * jarg1, void * jarg2) {
  math3D::Float *arg1 = 0 ;
  math3D::Float *arg2 = 0 ;
  
  arg1 = (math3D::Float *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return ;
  } 
  arg2 = (math3D::Float *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return ;
  } 
  math3D::fswap(*arg1,*arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_DEG2RAD(float jarg1) {
  float jresult ;
  math3D::Float arg1 ;
  math3D::Float result;
  
  arg1 = (math3D::Float)jarg1; 
  result = (math3D::Float)math3D::DEG2RAD(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_RAD2DEG(float jarg1) {
  float jresult ;
  math3D::Float arg1 ;
  math3D::Float result;
  
  arg1 = (math3D::Float)jarg1; 
  result = (math3D::Float)math3D::RAD2DEG(arg1);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Point_x_set(void * jarg1, int jarg2) {
  math3D::Point *arg1 = (math3D::Point *) 0 ;
  int arg2 ;
  
  arg1 = (math3D::Point *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_Point_x_get(void * jarg1) {
  int jresult ;
  math3D::Point *arg1 = (math3D::Point *) 0 ;
  int result;
  
  arg1 = (math3D::Point *)jarg1; 
  result = (int) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Point_y_set(void * jarg1, int jarg2) {
  math3D::Point *arg1 = (math3D::Point *) 0 ;
  int arg2 ;
  
  arg1 = (math3D::Point *)jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_Point_y_get(void * jarg1) {
  int jresult ;
  math3D::Point *arg1 = (math3D::Point *) 0 ;
  int result;
  
  arg1 = (math3D::Point *)jarg1; 
  result = (int) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Point__SWIG_0(int jarg1, int jarg2) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  math3D::Point *result = 0 ;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  result = (math3D::Point *)new math3D::Point(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Point__SWIG_1(int jarg1) {
  void * jresult ;
  int arg1 ;
  math3D::Point *result = 0 ;
  
  arg1 = (int)jarg1; 
  result = (math3D::Point *)new math3D::Point(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Point__SWIG_2() {
  void * jresult ;
  math3D::Point *result = 0 ;
  
  result = (math3D::Point *)new math3D::Point();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Point(void * jarg1) {
  math3D::Point *arg1 = (math3D::Point *) 0 ;
  
  arg1 = (math3D::Point *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3_x_set(void * jarg1, float jarg2) {
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec3_x_get(void * jarg1) {
  float jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (math3D::Float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3_y_set(void * jarg1, float jarg2) {
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec3_y_get(void * jarg1) {
  float jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (math3D::Float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec3_z_set(void * jarg1, float jarg2) {
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec3_z_get(void * jarg1) {
  float jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (math3D::Float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3__SWIG_0() {
  void * jresult ;
  math3D::Vec3 *result = 0 ;
  
  result = (math3D::Vec3 *)new math3D::Vec3();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3__SWIG_1(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  result = (math3D::Vec3 *)new math3D::Vec3(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec3__SWIG_2(void * jarg1) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Vec3 *)new math3D::Vec3((math3D::Vec3 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3_Null() {
  void * jresult ;
  math3D::Vec3 *result = 0 ;
  
  result = (math3D::Vec3 *) &math3D::Vec3::Null();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec3_getLen(void * jarg1) {
  float jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (math3D::Float)((math3D::Vec3 const *)arg1)->getLen();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec3_getSqLen(void * jarg1) {
  float jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (math3D::Float)((math3D::Vec3 const *)arg1)->getSqLen();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3_abs(void * jarg1) {
  void * jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = (arg1)->abs();
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Vec3_normalized(void * jarg1) {
  void * jresult ;
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  result = ((math3D::Vec3 const *)arg1)->normalized();
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Vec3(void * jarg1) {
  math3D::Vec3 *arg1 = (math3D::Vec3 *) 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1; 
  delete arg1;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_dot(void * jarg1, void * jarg2) {
  float jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)math3D::dot((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_distance(void * jarg1, void * jarg2) {
  float jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)math3D::distance((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_distanceSq(void * jarg1, void * jarg2) {
  float jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)math3D::distanceSq((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_angle(void * jarg1, void * jarg2) {
  float jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)math3D::angle((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_cross(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::cross((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_calcNormal(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::calcNormal((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec4_x_set(void * jarg1, float jarg2) {
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec4_x_get(void * jarg1) {
  float jresult ;
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  result = (math3D::Float) ((arg1)->x);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec4_y_set(void * jarg1, float jarg2) {
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec4_y_get(void * jarg1) {
  float jresult ;
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  result = (math3D::Float) ((arg1)->y);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec4_z_set(void * jarg1, float jarg2) {
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec4_z_get(void * jarg1) {
  float jresult ;
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  result = (math3D::Float) ((arg1)->z);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Vec4_w_set(void * jarg1, float jarg2) {
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  if (arg1) (arg1)->w = arg2;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Vec4_w_get(void * jarg1) {
  float jresult ;
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  result = (math3D::Float) ((arg1)->w);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec4__SWIG_0(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Vec4 *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  result = (math3D::Vec4 *)new math3D::Vec4(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec4__SWIG_1(void * jarg1, float jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Float arg2 ;
  math3D::Vec4 *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Float)jarg2; 
  result = (math3D::Vec4 *)new math3D::Vec4((math3D::Vec3 const &)*arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Vec4__SWIG_2(void * jarg1) {
  void * jresult ;
  math3D::Vec4 *arg1 = 0 ;
  math3D::Vec4 *result = 0 ;
  
  arg1 = (math3D::Vec4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec4 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Vec4 *)new math3D::Vec4((math3D::Vec4 const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Vec4(void * jarg1) {
  math3D::Vec4 *arg1 = (math3D::Vec4 *) 0 ;
  
  arg1 = (math3D::Vec4 *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Rect__SWIG_0() {
  void * jresult ;
  math3D::Rect *result = 0 ;
  
  result = (math3D::Rect *)new math3D::Rect();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Rect__SWIG_1(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Rect *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  result = (math3D::Rect *)new math3D::Rect(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Rect_OffsetRect(void * jarg1, float jarg2, float jarg3) {
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  
  arg1 = (math3D::Rect *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  (arg1)->OffsetRect(arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Rect_setLTRB(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  
  arg1 = (math3D::Rect *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  (arg1)->setLTRB(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Rect_setRight(void * jarg1, float jarg2) {
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Rect *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  (arg1)->setRight(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Rect_setBottom(void * jarg1, float jarg2) {
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float arg2 ;
  
  arg1 = (math3D::Rect *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  (arg1)->setBottom(arg2);
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Width(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Width();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Height(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Height();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Left(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Left();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Right(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Right();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Top(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Top();
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Rect_Bottom(void * jarg1) {
  float jresult ;
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Rect *)jarg1; 
  result = (math3D::Float)((math3D::Rect const *)arg1)->Bottom();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Rect(void * jarg1) {
  math3D::Rect *arg1 = (math3D::Rect *) 0 ;
  
  arg1 = (math3D::Rect *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Matrix__SWIG_0(unsigned int jarg1) {
  void * jresult ;
  bool arg1 ;
  math3D::Matrix *result = 0 ;
  
  arg1 = jarg1 ? true : false; 
  result = (math3D::Matrix *)new math3D::Matrix(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Matrix__SWIG_1() {
  void * jresult ;
  math3D::Matrix *result = 0 ;
  
  result = (math3D::Matrix *)new math3D::Matrix();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Matrix__SWIG_2(void * jarg1) {
  void * jresult ;
  math3D::Matrix *arg1 = 0 ;
  math3D::Matrix *result = 0 ;
  
  arg1 = (math3D::Matrix *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = (math3D::Matrix *)new math3D::Matrix((math3D::Matrix const &)*arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Matrix__SWIG_3(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6, float jarg7, float jarg8, float jarg9, float jarg10, float jarg11, float jarg12, float jarg13, float jarg14, float jarg15, float jarg16) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  math3D::Float arg6 ;
  math3D::Float arg7 ;
  math3D::Float arg8 ;
  math3D::Float arg9 ;
  math3D::Float arg10 ;
  math3D::Float arg11 ;
  math3D::Float arg12 ;
  math3D::Float arg13 ;
  math3D::Float arg14 ;
  math3D::Float arg15 ;
  math3D::Float arg16 ;
  math3D::Matrix *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  arg6 = (math3D::Float)jarg6; 
  arg7 = (math3D::Float)jarg7; 
  arg8 = (math3D::Float)jarg8; 
  arg9 = (math3D::Float)jarg9; 
  arg10 = (math3D::Float)jarg10; 
  arg11 = (math3D::Float)jarg11; 
  arg12 = (math3D::Float)jarg12; 
  arg13 = (math3D::Float)jarg13; 
  arg14 = (math3D::Float)jarg14; 
  arg15 = (math3D::Float)jarg15; 
  arg16 = (math3D::Float)jarg16; 
  result = (math3D::Matrix *)new math3D::Matrix(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Matrix(void * jarg1) {
  math3D::Matrix *arg1 = (math3D::Matrix *) 0 ;
  
  arg1 = (math3D::Matrix *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_loadIdentity(void * jarg1) {
  math3D::Matrix *arg1 = (math3D::Matrix *) 0 ;
  
  arg1 = (math3D::Matrix *)jarg1; 
  (arg1)->loadIdentity();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Identity() {
  void * jresult ;
  math3D::Matrix *result = 0 ;
  
  result = (math3D::Matrix *) &math3D::Matrix::Identity();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Inverse(void * jarg1) {
  void * jresult ;
  math3D::Matrix *arg1 = 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Matrix *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::Matrix::Inverse((math3D::Matrix const &)*arg1);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Translation(void * jarg1) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::Matrix::Translation((math3D::Vec3 const &)*arg1);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Scale(void * jarg1) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::Matrix::Scale((math3D::Vec3 const &)*arg1);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Rotation(void * jarg1, float jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Float arg2 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Float)jarg2; 
  result = math3D::Matrix::Rotation((math3D::Vec3 const &)*arg1,arg2);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Frustum(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  math3D::Float arg6 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  arg6 = (math3D::Float)jarg6; 
  result = math3D::Matrix::Frustum(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Ortho(float jarg1, float jarg2, float jarg3, float jarg4, float jarg5, float jarg6) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  math3D::Float arg6 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  arg6 = (math3D::Float)jarg6; 
  result = math3D::Matrix::Ortho(arg1,arg2,arg3,arg4,arg5,arg6);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Lookat(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::Matrix::Lookat((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Shadow(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Plane *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Plane *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Plane const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = math3D::Matrix::Shadow((math3D::Plane const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_getInverted(void * jarg1) {
  void * jresult ;
  math3D::Matrix *arg1 = (math3D::Matrix *) 0 ;
  math3D::Matrix result;
  
  arg1 = (math3D::Matrix *)jarg1; 
  result = ((math3D::Matrix const *)arg1)->getInverted();
  jresult = new math3D::Matrix((const math3D::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Matrix_Stack() {
  void * jresult ;
  math3D::Matrix::Stack *result = 0 ;
  
  result = (math3D::Matrix::Stack *)new math3D::Matrix::Stack();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Matrix_Stack(void * jarg1) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_clear(void * jarg1, void * jarg2) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Matrix *arg2 = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return ;
  } 
  (arg1)->clear((math3D::Matrix const &)*arg2);
}


SWIGEXPORT unsigned long SWIGSTDCALL CSharp_eh_Matrix_Stack_getStackSize(void * jarg1) {
  unsigned long jresult ;
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  size_t result;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  result = ((math3D::Matrix::Stack const *)arg1)->getStackSize();
  jresult = (unsigned long)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Matrix_Stack_getTop(void * jarg1) {
  void * jresult ;
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Matrix *result = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  result = (math3D::Matrix *) &((math3D::Matrix::Stack const *)arg1)->getTop();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_set(void * jarg1, void * jarg2) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Matrix *arg2 = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return ;
  } 
  (arg1)->set((math3D::Matrix const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_translate(void * jarg1, void * jarg2) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  (arg1)->translate((math3D::Vec3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_rotate(void * jarg1, void * jarg2, float jarg3) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float arg3 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  arg3 = (math3D::Float)jarg3; 
  (arg1)->rotate((math3D::Vec3 const &)*arg2,arg3);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_scale(void * jarg1, void * jarg2) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  (arg1)->scale((math3D::Vec3 const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_mult(void * jarg1, void * jarg2) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  math3D::Matrix *arg2 = 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return ;
  } 
  (arg1)->mult((math3D::Matrix const &)*arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_push(void * jarg1) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  (arg1)->push();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_pop(void * jarg1) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  (arg1)->pop();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Matrix_Stack_loadIdentity(void * jarg1) {
  math3D::Matrix::Stack *arg1 = (math3D::Matrix::Stack *) 0 ;
  
  arg1 = (math3D::Matrix::Stack *)jarg1; 
  (arg1)->loadIdentity();
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_transform__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Matrix *arg2 = 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::transform((math3D::Vec3 const &)*arg1,(math3D::Matrix const &)*arg2);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_transform__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Vec4 *arg1 = 0 ;
  math3D::Matrix *arg2 = 0 ;
  SwigValueWrapper< math3D::Vec4 > result;
  
  arg1 = (math3D::Vec4 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec4 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::transform((math3D::Vec4 const &)*arg1,(math3D::Matrix const &)*arg2);
  jresult = new math3D::Vec4((const math3D::Vec4 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_project(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Rect *arg2 = 0 ;
  math3D::Matrix *arg3 = 0 ;
  math3D::Matrix *arg4 = 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Rect *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Rect const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Matrix *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Matrix *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::project((math3D::Vec3 const &)*arg1,(math3D::Rect const &)*arg2,(math3D::Matrix const &)*arg3,(math3D::Matrix const &)*arg4);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_unproject(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Rect *arg2 = 0 ;
  math3D::Matrix *arg3 = 0 ;
  math3D::Matrix *arg4 = 0 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Rect *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Rect const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Matrix *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Matrix *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::unproject((math3D::Vec3 const &)*arg1,(math3D::Rect const &)*arg2,(math3D::Matrix const &)*arg3,(math3D::Matrix const &)*arg4);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Plane *)new math3D::Plane((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_1(float jarg1, float jarg2, float jarg3, float jarg4) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  result = (math3D::Plane *)new math3D::Plane(arg1,arg2,arg3,arg4);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_2(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  result = (math3D::Plane *)new math3D::Plane(arg1,arg2,arg3);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_3(float jarg1, float jarg2) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Float arg2 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  result = (math3D::Plane *)new math3D::Plane(arg1,arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_4(float jarg1) {
  void * jresult ;
  math3D::Float arg1 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Float)jarg1; 
  result = (math3D::Plane *)new math3D::Plane(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Plane__SWIG_5() {
  void * jresult ;
  math3D::Plane *result = 0 ;
  
  result = (math3D::Plane *)new math3D::Plane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Plane(void * jarg1) {
  math3D::Plane *arg1 = (math3D::Plane *) 0 ;
  
  arg1 = (math3D::Plane *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Plane_getNormal(void * jarg1) {
  void * jresult ;
  math3D::Plane *arg1 = (math3D::Plane *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::Plane *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::Plane const *)arg1)->getNormal();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Plane_getD(void * jarg1) {
  float jresult ;
  math3D::Plane *arg1 = (math3D::Plane *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Plane *)jarg1; 
  result = (math3D::Float)((math3D::Plane const *)arg1)->getD();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Plane_getIntersectionWithLine(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  math3D::Plane *arg1 = (math3D::Plane *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Float *arg4 = 0 ;
  bool result;
  
  arg1 = (math3D::Plane *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Float *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Plane const *)arg1)->getIntersectionWithLine((math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Plane_getIntersectionWithPlane(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  math3D::Plane *arg1 = (math3D::Plane *) 0 ;
  math3D::Plane *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Vec3 *arg4 = 0 ;
  bool result;
  
  arg1 = (math3D::Plane *)jarg1; 
  arg2 = (math3D::Plane *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Plane const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Vec3 *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Plane const *)arg1)->getIntersectionWithPlane((math3D::Plane const &)*arg2,*arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Ray__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Ray *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::Ray *)new math3D::Ray((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Ray__SWIG_1(int jarg1, int jarg2, void * jarg3, void * jarg4, void * jarg5) {
  void * jresult ;
  int arg1 ;
  int arg2 ;
  math3D::Rect *arg3 = 0 ;
  math3D::Matrix *arg4 = 0 ;
  math3D::Matrix *arg5 = 0 ;
  math3D::Ray *result = 0 ;
  
  arg1 = (int)jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (math3D::Rect *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Rect const & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Matrix *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  arg5 = (math3D::Matrix *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = (math3D::Ray *)new math3D::Ray(arg1,arg2,(math3D::Rect const &)*arg3,(math3D::Matrix const &)*arg4,(math3D::Matrix const &)*arg5);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Ray(void * jarg1) {
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  
  arg1 = (math3D::Ray *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Ray_getOrigin(void * jarg1) {
  void * jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::Ray *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::Ray const *)arg1)->getOrigin();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Ray_getDirection(void * jarg1) {
  void * jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::Ray *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::Ray const *)arg1)->getDirection();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Ray_getIntersectionWithTriangle(void * jarg1, void * jarg2, void * jarg3, void * jarg4, void * jarg5) {
  unsigned int jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Vec3 *arg4 = 0 ;
  math3D::Float *arg5 = 0 ;
  bool result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Vec3 *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg5 = (math3D::Float *)jarg5;
  if (!arg5) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Ray const *)arg1)->getIntersectionWithTriangle((math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3,(math3D::Vec3 const &)*arg4,*arg5);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Ray_getIntersectionWithAABBox__SWIG_0(void * jarg1, void * jarg2, void * jarg3, float jarg4, float jarg5) {
  unsigned int jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  math3D::Float *arg3 = 0 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  bool result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  result = (bool)((math3D::Ray const *)arg1)->getIntersectionWithAABBox((math3D::AABBox const &)*arg2,*arg3,arg4,arg5);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Ray_getIntersectionWithAABBox__SWIG_1(void * jarg1, void * jarg2, void * jarg3, float jarg4) {
  unsigned int jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  math3D::Float *arg3 = 0 ;
  math3D::Float arg4 ;
  bool result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  arg4 = (math3D::Float)jarg4; 
  result = (bool)((math3D::Ray const *)arg1)->getIntersectionWithAABBox((math3D::AABBox const &)*arg2,*arg3,arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Ray_getIntersectionWithAABBox__SWIG_2(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  math3D::Float *arg3 = 0 ;
  bool result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Ray const *)arg1)->getIntersectionWithAABBox((math3D::AABBox const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Ray_getSqDistanceToPoint(void * jarg1, void * jarg2, void * jarg3) {
  float jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float *arg3 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)((math3D::Ray const *)arg1)->getSqDistanceToPoint((math3D::Vec3 const &)*arg2,*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Ray_getIntersectionWithSphere(void * jarg1, void * jarg2, float jarg3, void * jarg4) {
  unsigned int jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Float arg3 ;
  math3D::Float *arg4 = 0 ;
  bool result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Ray const *)arg1)->getIntersectionWithSphere((math3D::Vec3 const &)*arg2,arg3,*arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Ray_getSqDistanceToRay__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  float jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Ray *arg2 = 0 ;
  math3D::Float *arg3 = (math3D::Float *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Ray *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Ray const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Float *)jarg3; 
  result = (math3D::Float)((math3D::Ray const *)arg1)->getSqDistanceToRay((math3D::Ray const &)*arg2,arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_Ray_getSqDistanceToRay__SWIG_1(void * jarg1, void * jarg2) {
  float jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Ray *arg2 = 0 ;
  math3D::Float result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Ray *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Ray const & type is null", 0);
    return 0;
  } 
  result = (math3D::Float)((math3D::Ray const *)arg1)->getSqDistanceToRay((math3D::Ray const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Ray_getClosestPointToRay(void * jarg1, void * jarg2, void * jarg3) {
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Ray *arg2 = 0 ;
  math3D::Float *arg3 = 0 ;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Ray *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Ray const & type is null", 0);
    return ;
  } 
  arg3 = (math3D::Float *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Float & type is null", 0);
    return ;
  } 
  ((math3D::Ray const *)arg1)->getClosestPointToRay((math3D::Ray const &)*arg2,*arg3);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Ray_getPointAt(void * jarg1, float jarg2) {
  void * jresult ;
  math3D::Ray *arg1 = (math3D::Ray *) 0 ;
  math3D::Float arg2 ;
  math3D::Vec3 result;
  
  arg1 = (math3D::Ray *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  result = ((math3D::Ray const *)arg1)->getPointAt(arg2);
  jresult = new math3D::Vec3((const math3D::Vec3 &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_transform__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Ray *arg1 = 0 ;
  math3D::Matrix *arg2 = 0 ;
  SwigValueWrapper< math3D::Ray > result;
  
  arg1 = (math3D::Ray *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Ray const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::transform((math3D::Ray const &)*arg1,(math3D::Matrix const &)*arg2);
  jresult = new math3D::Ray((const math3D::Ray &)result); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_AABBox__SWIG_0() {
  void * jresult ;
  math3D::AABBox *result = 0 ;
  
  result = (math3D::AABBox *)new math3D::AABBox();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_AABBox__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::Vec3 *arg1 = 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::AABBox *result = 0 ;
  
  arg1 = (math3D::Vec3 *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::AABBox *)new math3D::AABBox((math3D::Vec3 const &)*arg1,(math3D::Vec3 const &)*arg2);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_AABBox(void * jarg1) {
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  delete arg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_AABBox_getMin(void * jarg1) {
  void * jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::AABBox const *)arg1)->getMin();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_AABBox_getMax(void * jarg1) {
  void * jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::AABBox const *)arg1)->getMax();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_AABBox_getSize(void * jarg1) {
  void * jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::AABBox const *)arg1)->getSize();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_AABBox_getCenter(void * jarg1) {
  void * jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Vec3 *result = 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Vec3 *) &((math3D::AABBox const *)arg1)->getCenter();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_AABBox_getRadius(void * jarg1) {
  float jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Float)((math3D::AABBox const *)arg1)->getRadius();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_AABBox_getCorners(void * jarg1) {
  void * jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  std::vector< math3D::Vec3 > result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = ((math3D::AABBox const *)arg1)->getCorners();
  jresult = new std::vector< math3D::Vec3 >((const std::vector< math3D::Vec3 > &)result); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_AABBox_isInside__SWIG_0(void * jarg1, void * jarg2) {
  int jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::AABBox::INSIDE_RESULT result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (math3D::AABBox::INSIDE_RESULT)((math3D::AABBox const *)arg1)->isInside((math3D::Vec3 const &)*arg2);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_AABBox_isInside__SWIG_1(void * jarg1, void * jarg2) {
  int jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  math3D::AABBox::INSIDE_RESULT result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  result = (math3D::AABBox::INSIDE_RESULT)((math3D::AABBox const *)arg1)->isInside((math3D::AABBox const &)*arg2);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_AABBox_intersect(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  bool result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::AABBox const *)arg1)->intersect((math3D::AABBox const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_AABBox_divide(void * jarg1, void * jarg2, void * jarg3) {
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  math3D::AABBox *arg3 = 0 ;
  
  arg1 = (math3D::AABBox *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox & type is null", 0);
    return ;
  } 
  arg3 = (math3D::AABBox *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox & type is null", 0);
    return ;
  } 
  ((math3D::AABBox const *)arg1)->divide(*arg2,*arg3);
}


SWIGEXPORT float SWIGSTDCALL CSharp_eh_AABBox_getVolume(void * jarg1) {
  float jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  math3D::Float result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (math3D::Float)((math3D::AABBox const *)arg1)->getVolume();
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_AABBox_valid(void * jarg1) {
  unsigned int jresult ;
  math3D::AABBox *arg1 = (math3D::AABBox *) 0 ;
  bool result;
  
  arg1 = (math3D::AABBox *)jarg1; 
  result = (bool)((math3D::AABBox const *)arg1)->valid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_transform__SWIG_3(void * jarg1, void * jarg2) {
  void * jresult ;
  math3D::AABBox *arg1 = 0 ;
  math3D::Matrix *arg2 = 0 ;
  math3D::AABBox result;
  
  arg1 = (math3D::AABBox *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = math3D::transform((math3D::AABBox const &)*arg1,(math3D::Matrix const &)*arg2);
  jresult = new math3D::AABBox((const math3D::AABBox &)result); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Frustum_extractFrom(void * jarg1, void * jarg2, void * jarg3) {
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Matrix *arg2 = 0 ;
  math3D::Matrix *arg3 = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::Matrix *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return ;
  } 
  arg3 = (math3D::Matrix *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return ;
  } 
  (arg1)->extractFrom((math3D::Matrix const &)*arg2,(math3D::Matrix const &)*arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Frustum_isPointInside(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  bool result;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (bool)((math3D::Frustum const *)arg1)->isPointInside((math3D::Vec3 const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Frustum_isAABBInside__SWIG_0(void * jarg1, void * jarg2, void * jarg3) {
  unsigned int jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  unsigned int result;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return 0;
  } 
  result = (unsigned int)((math3D::Frustum const *)arg1)->isAABBInside((math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Frustum_isAABBInside__SWIG_1(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::AABBox *arg2 = 0 ;
  unsigned int result;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::AABBox *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::AABBox const & type is null", 0);
    return 0;
  } 
  result = (unsigned int)((math3D::Frustum const *)arg1)->isAABBInside((math3D::AABBox const &)*arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Frustum_isSphereInside(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  unsigned int jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  bool result;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  result = (bool)((math3D::Frustum const *)arg1)->isSphereInside(arg2,arg3,arg4,arg5);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_Frustum_isCubeInside(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  unsigned int jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Float arg2 ;
  math3D::Float arg3 ;
  math3D::Float arg4 ;
  math3D::Float arg5 ;
  bool result;
  
  arg1 = (math3D::Frustum *)jarg1; 
  arg2 = (math3D::Float)jarg2; 
  arg3 = (math3D::Float)jarg3; 
  arg4 = (math3D::Float)jarg4; 
  arg5 = (math3D::Float)jarg5; 
  result = (bool)((math3D::Frustum const *)arg1)->isCubeInside(arg2,arg3,arg4,arg5);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getTopPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getTopPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getBottomPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getBottomPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getLeftPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getLeftPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getRightPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getRightPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getBackPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getBackPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Frustum_getFrontPlane(void * jarg1) {
  void * jresult ;
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  math3D::Plane *result = 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  result = (math3D::Plane *) &((math3D::Frustum const *)arg1)->getFrontPlane();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Frustum() {
  void * jresult ;
  math3D::Frustum *result = 0 ;
  
  result = (math3D::Frustum *)new math3D::Frustum();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Frustum(void * jarg1) {
  math3D::Frustum *arg1 = (math3D::Frustum *) 0 ;
  
  arg1 = (math3D::Frustum *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IGeometry_AddVertex(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  swig::IGeometry *arg1 = (swig::IGeometry *) 0 ;
  math3D::Vec3 *arg2 = 0 ;
  math3D::Vec3 *arg3 = 0 ;
  math3D::Vec3 *arg4 = 0 ;
  std::shared_ptr< swig::IGeometry > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IGeometry > *)jarg1;
  arg1 = (swig::IGeometry *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (math3D::Vec3 *)jarg2;
  if (!arg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  arg3 = (math3D::Vec3 *)jarg3;
  if (!arg3) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  arg4 = (math3D::Vec3 *)jarg4;
  if (!arg4) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Vec3 const & type is null", 0);
    return ;
  } 
  (arg1)->AddVertex((math3D::Vec3 const &)*arg2,(math3D::Vec3 const &)*arg3,(math3D::Vec3 const &)*arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IGeometry(void * jarg1) {
  swig::IGeometry *arg1 = (swig::IGeometry *) 0 ;
  std::shared_ptr< swig::IGeometry > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IGeometry > *)jarg1;
  arg1 = (swig::IGeometry *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetDiffuseColor(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetDiffuseColor(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetAmbientColor(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetAmbientColor(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetSpecularColor(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetSpecularColor(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetSpecularFactor(void * jarg1, float jarg2) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  float arg2 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  (arg1)->SetSpecularFactor(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetEmissionColor(void * jarg1, float jarg2, float jarg3, float jarg4, float jarg5) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (float)jarg2; 
  arg3 = (float)jarg3; 
  arg4 = (float)jarg4; 
  arg5 = (float)jarg5; 
  (arg1)->SetEmissionColor(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetDiffuseTexture(void * jarg1, wchar_t * jarg2) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  std::wstring arg2 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetDiffuseTexture(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetReflectionTexture(void * jarg1, wchar_t * jarg2) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  std::wstring arg2 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetReflectionTexture(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IMaterial_SetBumpTexture(void * jarg1, wchar_t * jarg2) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  std::wstring arg2 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return ;
  }
  (&arg2)->assign(jarg2); 
  (arg1)->SetBumpTexture(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IMaterial(void * jarg1) {
  swig::IMaterial *arg1 = (swig::IMaterial *) 0 ;
  std::shared_ptr< swig::IMaterial > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IMaterial > *)jarg1;
  arg1 = (swig::IMaterial *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_ISceneNode(void * jarg1) {
  swig::ISceneNode *arg1 = (swig::ISceneNode *) 0 ;
  std::shared_ptr< swig::ISceneNode > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::ISceneNode > *)jarg1;
  arg1 = (swig::ISceneNode *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_ISceneNode() {
  void * jresult ;
  swig::ISceneNode *result = 0 ;
  
  result = (swig::ISceneNode *)new swig::ISceneNode();
  
  jresult = result ? new std::shared_ptr<  swig::ISceneNode >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_IShapeNode() {
  void * jresult ;
  swig::IShapeNode *result = 0 ;
  
  result = (swig::IShapeNode *)new swig::IShapeNode();
  
  jresult = result ? new std::shared_ptr<  swig::IShapeNode >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IShapeNode(void * jarg1) {
  swig::IShapeNode *arg1 = (swig::IShapeNode *) 0 ;
  std::shared_ptr< swig::IShapeNode > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IShapeNode > *)jarg1;
  arg1 = (swig::IShapeNode *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IGroupNode_AddChildNode(void * jarg1, void * jarg2) {
  swig::IGroupNode *arg1 = (swig::IGroupNode *) 0 ;
  std::shared_ptr< swig::ISceneNode > arg2 ;
  std::shared_ptr< swig::IGroupNode > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IGroupNode > *)jarg1;
  arg1 = (swig::IGroupNode *)(smartarg1 ? smartarg1->get() : 0); 
  if (jarg2) arg2 = *(std::shared_ptr< swig::ISceneNode > *)jarg2; 
  (arg1)->AddChildNode(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IGroupNode(void * jarg1) {
  swig::IGroupNode *arg1 = (swig::IGroupNode *) 0 ;
  std::shared_ptr< swig::IGroupNode > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IGroupNode > *)jarg1;
  arg1 = (swig::IGroupNode *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_CreateGeometry() {
  void * jresult ;
  std::shared_ptr< swig::IGeometry > result;
  
  result = swig::Scene::CreateGeometry();
  jresult = result ? new std::shared_ptr< swig::IGeometry >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_CreateMaterial() {
  void * jresult ;
  std::shared_ptr< swig::IMaterial > result;
  
  result = swig::Scene::CreateMaterial();
  jresult = result ? new std::shared_ptr< swig::IMaterial >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_CreateShapeNode(void * jarg1, void * jarg2) {
  void * jresult ;
  std::shared_ptr< swig::IMaterial > arg1 ;
  std::shared_ptr< swig::IGeometry > arg2 ;
  std::shared_ptr< swig::IShapeNode > result;
  
  if (jarg1) arg1 = *(std::shared_ptr< swig::IMaterial > *)jarg1; 
  if (jarg2) arg2 = *(std::shared_ptr< swig::IGeometry > *)jarg2; 
  result = swig::Scene::CreateShapeNode(arg1,arg2);
  jresult = result ? new std::shared_ptr< swig::IShapeNode >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_CreateGroupNode(void * jarg1) {
  void * jresult ;
  math3D::Matrix *arg1 = 0 ;
  std::shared_ptr< swig::IGroupNode > result;
  
  arg1 = (math3D::Matrix *)jarg1;
  if (!arg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "math3D::Matrix const & type is null", 0);
    return 0;
  } 
  result = swig::Scene::CreateGroupNode((math3D::Matrix const &)*arg1);
  jresult = result ? new std::shared_ptr< swig::IGroupNode >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_TryGetGroupNodeFromHandle(void * jarg1) {
  void * jresult ;
  void *arg1 = (void *) 0 ;
  std::shared_ptr< swig::IGroupNode > result;
  
  arg1 = (void *)jarg1; 
  result = swig::Scene::TryGetGroupNodeFromHandle(arg1);
  jresult = result ? new std::shared_ptr< swig::IGroupNode >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_Scene_NodeToHandle(void * jarg1) {
  void * jresult ;
  std::shared_ptr< swig::ISceneNode > arg1 ;
  void *result = 0 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< swig::ISceneNode > *)jarg1; 
  result = (void *)swig::Scene::NodeToHandle(arg1);
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Scene() {
  void * jresult ;
  swig::Scene *result = 0 ;
  
  result = (swig::Scene *)new swig::Scene();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Scene(void * jarg1) {
  swig::Scene *arg1 = (swig::Scene *) 0 ;
  
  arg1 = (swig::Scene *)jarg1; 
  delete arg1;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IController_LBUTTON_get() {
  int jresult ;
  int result;
  
  result = (int)swig::IController::LBUTTON;
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IController_RBUTTON_get() {
  int jresult ;
  int result;
  
  result = (int)swig::IController::RBUTTON;
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IController_SHIFT_get() {
  int jresult ;
  int result;
  
  result = (int)swig::IController::SHIFT;
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IController_CONTROL_get() {
  int jresult ;
  int result;
  
  result = (int)swig::IController::CONTROL;
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IController_MBUTTON_get() {
  int jresult ;
  int result;
  
  result = (int)swig::IController::MBUTTON;
  jresult = result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_OnMouseMove(void * jarg1, int jarg2, int jarg3, int jarg4) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  swig::IController::Flags arg2 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = (swig::IController *)jarg1; 
  arg2 = (swig::IController::Flags)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  (arg1)->OnMouseMove(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_OnMouseDown(void * jarg1, int jarg2, int jarg3, int jarg4) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  swig::IController::Flags arg2 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = (swig::IController *)jarg1; 
  arg2 = (swig::IController::Flags)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  (arg1)->OnMouseDown(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_OnMouseUp(void * jarg1, int jarg2, int jarg3, int jarg4) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  swig::IController::Flags arg2 ;
  int arg3 ;
  int arg4 ;
  
  arg1 = (swig::IController *)jarg1; 
  arg2 = (swig::IController::Flags)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  (arg1)->OnMouseUp(arg2,arg3,arg4);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_OnMouseWheel(void * jarg1, int jarg2, short jarg3, int jarg4, int jarg5) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  swig::IController::Flags arg2 ;
  short arg3 ;
  int arg4 ;
  int arg5 ;
  
  arg1 = (swig::IController *)jarg1; 
  arg2 = (swig::IController::Flags)jarg2; 
  arg3 = (short)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (int)jarg5; 
  (arg1)->OnMouseWheel(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_OnKeyDown(void * jarg1, int jarg2) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  int arg2 ;
  
  arg1 = (swig::IController *)jarg1; 
  arg2 = (int)jarg2; 
  (arg1)->OnKeyDown(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IController_Animate(void * jarg1) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  
  arg1 = (swig::IController *)jarg1; 
  (arg1)->Animate();
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IController(void * jarg1) {
  swig::IController *arg1 = (swig::IController *) 0 ;
  
  arg1 = (swig::IController *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_Callback(void * jarg1) {
  swig::Callback *arg1 = (swig::Callback *) 0 ;
  
  arg1 = (swig::Callback *)jarg1; 
  delete arg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Callback_Call(void * jarg1, float jarg2) {
  swig::Callback *arg1 = (swig::Callback *) 0 ;
  float arg2 ;
  
  arg1 = (swig::Callback *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->Call(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Callback_CallSwigExplicitCallback(void * jarg1, float jarg2) {
  swig::Callback *arg1 = (swig::Callback *) 0 ;
  float arg2 ;
  
  arg1 = (swig::Callback *)jarg1; 
  arg2 = (float)jarg2; 
  (arg1)->swig::Callback::Call(arg2);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_Callback() {
  void * jresult ;
  swig::Callback *result = 0 ;
  
  result = (swig::Callback *)new SwigDirector_Callback();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_Callback_director_connect(void *objarg, SwigDirector_Callback::SWIG_Callback0_t callback0) {
  swig::Callback *obj = (swig::Callback *)objarg;
  SwigDirector_Callback *director = dynamic_cast<SwigDirector_Callback *>(obj);
  if (director) {
    director->swig_connect_director(callback0);
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IViewport_SetDisplayRect(void * jarg1, int jarg2, int jarg3, int jarg4, int jarg5) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  arg4 = (int)jarg4; 
  arg5 = (int)jarg5; 
  (arg1)->SetDisplayRect(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IViewport_DrawScene(void * jarg1) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  (arg1)->DrawScene();
}


SWIGEXPORT char * SWIGSTDCALL CSharp_eh_IViewport_GetDriverInfo(void * jarg1) {
  char * jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  std::string result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  result = (arg1)->GetDriverInfo();
  jresult = SWIG_csharp_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IViewport_IsValid(void * jarg1) {
  unsigned int jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  result = (bool)(arg1)->IsValid();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IViewport_Control(void * jarg1) {
  void * jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  swig::IController *result = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  result = (swig::IController *)(arg1)->Control();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IViewport_SetModeFlag(void * jarg1, int jarg2, unsigned int jarg3) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  Mode arg2 ;
  bool arg3 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (Mode)jarg2; 
  arg3 = jarg3 ? true : false; 
  (arg1)->SetModeFlag(arg2,arg3);
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IViewport_GetModeFlag(void * jarg1, int jarg2) {
  unsigned int jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  Mode arg2 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (Mode)jarg2; 
  result = (bool)(arg1)->GetModeFlag(arg2);
  jresult = result; 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IViewport_GetCameraCount(void * jarg1) {
  int jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)(arg1)->GetCameraCount();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IViewport_GetCameraName(void * jarg1, int jarg2) {
  void * jresult ;
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  int arg2 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  result = (arg1)->GetCameraName(arg2);
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IViewport_SetCamera(void * jarg1, int jarg2) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  int arg2 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  (arg1)->SetCamera(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IViewport_SetScene(void * jarg1, void * jarg2) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::ISceneNode > arg2 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  if (jarg2) arg2 = *(std::shared_ptr< swig::ISceneNode > *)jarg2; 
  (arg1)->SetScene(arg2);
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IViewport(void * jarg1) {
  swig::IViewport *arg1 = (swig::IViewport *) 0 ;
  std::shared_ptr< swig::IViewport > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IViewport > *)jarg1;
  arg1 = (swig::IViewport *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_CreateViewport(void * jarg1) {
  void * jresult ;
  void *arg1 = (void *) 0 ;
  std::shared_ptr< swig::IViewport > result;
  
  arg1 = (void *)jarg1; 
  result = swig::CreateViewport(arg1);
  jresult = result ? new std::shared_ptr< swig::IViewport >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IPlugIn_GetAboutString(void * jarg1) {
  void * jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  std::shared_ptr< swig::IPlugIn const > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr< const swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  result = ((swig::IPlugIn const *)arg1)->GetAboutString();
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT int SWIGSTDCALL CSharp_eh_IPlugIn_GetFileTypeCount(void * jarg1) {
  int jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  std::shared_ptr< swig::IPlugIn const > *smartarg1 = 0 ;
  int result;
  
  
  smartarg1 = (std::shared_ptr< const swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  result = (int)((swig::IPlugIn const *)arg1)->GetFileTypeCount();
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IPlugIn_GetFileType(void * jarg1, int jarg2) {
  void * jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  int arg2 ;
  std::shared_ptr< swig::IPlugIn > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  result = (arg1)->GetFileType(arg2);
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_IPlugIn_GetFileExtention(void * jarg1, int jarg2) {
  void * jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  int arg2 ;
  std::shared_ptr< swig::IPlugIn > *smartarg1 = 0 ;
  std::wstring result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  arg2 = (int)jarg2; 
  result = (arg1)->GetFileExtention(arg2);
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IPlugIn_ReadFile__SWIG_0(void * jarg1, wchar_t * jarg2, void * jarg3, void * jarg4) {
  unsigned int jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  std::wstring arg2 ;
  void *arg3 = (void *) 0 ;
  swig::Callback *arg4 = (swig::Callback *) 0 ;
  std::shared_ptr< swig::IPlugIn > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  arg3 = (void *)jarg3; 
  arg4 = (swig::Callback *)jarg4; 
  result = (bool)(arg1)->ReadFile(arg2,arg3,arg4);
  jresult = result; 
  return jresult;
}


SWIGEXPORT unsigned int SWIGSTDCALL CSharp_eh_IPlugIn_ReadFile__SWIG_1(void * jarg1, wchar_t * jarg2, void * jarg3) {
  unsigned int jresult ;
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  std::wstring arg2 ;
  void *arg3 = (void *) 0 ;
  std::shared_ptr< swig::IPlugIn > *smartarg1 = 0 ;
  bool result;
  
  
  smartarg1 = (std::shared_ptr<  swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  if (!jarg2) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  (&arg2)->assign(jarg2); 
  arg3 = (void *)jarg3; 
  result = (bool)(arg1)->ReadFile(arg2,arg3);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_IPlugIn() {
  void * jresult ;
  swig::IPlugIn *result = 0 ;
  
  result = (swig::IPlugIn *)new SwigDirector_IPlugIn();
  
  jresult = result ? new std::shared_ptr<  swig::IPlugIn >(result SWIG_NO_NULL_DELETER_1) : 0;
  
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_IPlugIn(void * jarg1) {
  swig::IPlugIn *arg1 = (swig::IPlugIn *) 0 ;
  std::shared_ptr< swig::IPlugIn > *smartarg1 = 0 ;
  
  
  smartarg1 = (std::shared_ptr<  swig::IPlugIn > *)jarg1;
  arg1 = (swig::IPlugIn *)(smartarg1 ? smartarg1->get() : 0); 
  (void)arg1; delete smartarg1;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_IPlugIn_director_connect(void *objarg, SwigDirector_IPlugIn::SWIG_Callback0_t callback0, SwigDirector_IPlugIn::SWIG_Callback1_t callback1, SwigDirector_IPlugIn::SWIG_Callback2_t callback2, SwigDirector_IPlugIn::SWIG_Callback3_t callback3, SwigDirector_IPlugIn::SWIG_Callback4_t callback4, SwigDirector_IPlugIn::SWIG_Callback5_t callback5) {
  std::shared_ptr< swig::IPlugIn > *obj = (std::shared_ptr< swig::IPlugIn > *)objarg;
  // Keep a local instance of the smart pointer around while we are using the raw pointer
  // Avoids using smart pointer specific API.
  SwigDirector_IPlugIn *director = dynamic_cast<SwigDirector_IPlugIn *>(obj->operator->());
  if (director) {
    director->swig_connect_director(callback0, callback1, callback2, callback3, callback4, callback5);
  }
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_SceneIO_RegisterPlugIn(void * jarg1) {
  std::shared_ptr< swig::IPlugIn > arg1 ;
  
  if (jarg1) arg1 = *(std::shared_ptr< swig::IPlugIn > *)jarg1; 
  swig::SceneIO::RegisterPlugIn(arg1);
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_SceneIO_TryRead__SWIG_0(wchar_t * jarg1, void * jarg2) {
  void * jresult ;
  std::wstring arg1 ;
  swig::Callback *arg2 = (swig::Callback *) 0 ;
  std::shared_ptr< swig::IGroupNode > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  arg2 = (swig::Callback *)jarg2; 
  result = swig::SceneIO::TryRead(arg1,arg2);
  jresult = result ? new std::shared_ptr< swig::IGroupNode >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_SceneIO_TryRead__SWIG_1(wchar_t * jarg1) {
  void * jresult ;
  std::wstring arg1 ;
  std::shared_ptr< swig::IGroupNode > result;
  
  if (!jarg1) {
    SWIG_CSharpSetPendingExceptionArgument(SWIG_CSharpArgumentNullException, "null wstring", 0);
    return 0;
  }
  (&arg1)->assign(jarg1); 
  result = swig::SceneIO::TryRead(arg1);
  jresult = result ? new std::shared_ptr< swig::IGroupNode >(result) : 0; 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_SceneIO_GetFileWildcards__SWIG_0(unsigned int jarg1) {
  void * jresult ;
  bool arg1 ;
  std::wstring result;
  
  arg1 = jarg1 ? true : false; 
  result = swig::SceneIO::GetFileWildcards(arg1);
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_SceneIO_GetFileWildcards__SWIG_1() {
  void * jresult ;
  std::wstring result;
  
  result = swig::SceneIO::GetFileWildcards();
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_SceneIO_GetAboutString() {
  void * jresult ;
  std::wstring result;
  
  result = swig::SceneIO::GetAboutString();
  jresult = SWIG_csharp_wstring_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * SWIGSTDCALL CSharp_eh_new_SceneIO() {
  void * jresult ;
  swig::SceneIO *result = 0 ;
  
  result = (swig::SceneIO *)new swig::SceneIO();
  jresult = (void *)result; 
  return jresult;
}


SWIGEXPORT void SWIGSTDCALL CSharp_eh_delete_SceneIO(void * jarg1) {
  swig::SceneIO *arg1 = (swig::SceneIO *) 0 ;
  
  arg1 = (swig::SceneIO *)jarg1; 
  delete arg1;
}


SWIGEXPORT std::shared_ptr< swig::ISceneNode > * SWIGSTDCALL CSharp_eh_IShapeNode_SWIGSmartPtrUpcast(std::shared_ptr< swig::IShapeNode > *jarg1) {
    return jarg1 ? new std::shared_ptr< swig::ISceneNode >(*jarg1) : 0;
}

SWIGEXPORT std::shared_ptr< swig::ISceneNode > * SWIGSTDCALL CSharp_eh_IGroupNode_SWIGSmartPtrUpcast(std::shared_ptr< swig::IGroupNode > *jarg1) {
    return jarg1 ? new std::shared_ptr< swig::ISceneNode >(*jarg1) : 0;
}

#ifdef __cplusplus
}
#endif

